<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>MediaServer&#x542f;&#x52a8;&#x6d41;&#x7a0b;</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="mediaserver启动流程">MediaServer启动流程</h1>
<p>在main_demaiserver.cpp启动的该服务，这部分代码没什么内容分为两部分</p>
<ul>
<li>创建MMediaPlayerService
创建一个NuPlayerFactory注册到，map容器sFactoryMap中。key是字符串比如NU_PLAYER</li>
<li>ResourceManagerService
创建ResourceObserverService对象，然后注册到ResourceManagerService中。</li>
</ul>
<h1 id="mediaplayer播放流程分析">MediaPlayer播放流程分析</h1>
<h2 id="使用-mediaplayer-api-播放音视频的流程">使用 MediaPlayer API 播放音视频的流程</h2>
<pre><code class="language-java">        <span class="hljs-comment">// 初始化MediaPlayer</span>
        <span class="hljs-comment">// MediaPlayer类位于frameworks/base/media/java/android/media/MediaPlayer.java</span>
        mediaPlayer = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MediaPlayer</span>();
        <span class="hljs-keyword">try</span> {
            <span class="hljs-comment">// 设置音频资源 (本地文件或网络URL)</span>
            mediaPlayer.setDataSource(<span class="hljs-string">&quot;https://www.example.com/audio.mp3&quot;</span>); <span class="hljs-comment">// 网络音频文件</span>
            <span class="hljs-comment">// mediaPlayer.setDataSource(&quot;/sdcard/Music/sample.mp3&quot;);       // 本地音频文件</span>
            <span class="hljs-comment">// 异步准备播放器</span>
            mediaPlayer.setOnPreparedListener(mp -&gt;{
                Log.d(TAG, <span class="hljs-string">&quot;MediaPlayer准备完成，开始播放&quot;</span>)
                mediaPlayer.start();<span class="hljs-comment">// 开始播放</span>
            });
            prepareAsync(); <span class="hljs-comment">// 异步准备</span>
        } <span class="hljs-keyword">catch</span> (Exception e) {
            Log.e(<span class="hljs-string">&quot;MediaPlayer&quot;</span>, <span class="hljs-string">&quot;初始化失败：&quot;</span> + e.getMessage());
        }
        <span class="hljs-comment">//播放进行中</span>
        mediaPlayer.pause(); <span class="hljs-comment">// 暂停播放</span>
        mediaPlayer.stop(); <span class="hljs-comment">// 停止播放</span>
        mediaPlayer.prepare(); <span class="hljs-comment">// 停止后需要重新准备播放器</span>
</code></pre>
<p>上面就是使用MediaPlayer API的简化的播放流程。MediaPlayer是支持同步准备的，该代码使用了异步准备，目的是为了不会卡住UI，当准备完成之后会触发MediaPlayer中的函数OnPreparedListener，然后开始播放。
有AudioTrack的播放流程不同的是，不需要write。数据的读写都是MediaPlayer控制，这大大减少了APP的开发难度
接下来我们就按照播放流程来分析MediaServer的控制流。</p>
<h2 id="控制流">控制流</h2>
<h3 id="new-meidaplayer">New MeidaPlayer</h3>
<pre><code class="language-java">MediaPlayer.java
   <span class="hljs-keyword">public</span> <span class="hljs-title function_">MediaPlayer</span><span class="hljs-params">()</span> {
        <span class="hljs-built_in">this</span>(<span class="hljs-comment">/*context=*/</span><span class="hljs-literal">null</span>, AudioSystem.AUDIO_SESSION_ALLOCATE);
    }
    <span class="hljs-keyword">private</span> <span class="hljs-title function_">MediaPlayer</span><span class="hljs-params">(Context context, <span class="hljs-type">int</span> sessionId)</span> {
        <span class="hljs-comment">// 调用父类构造函数,设置默认的音频属性</span>
        <span class="hljs-built_in">super</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">AudioAttributes</span>.Builder().build(),
                AudioPlaybackConfiguration.PLAYER_TYPE_JAM_MEDIAPLAYER);

        <span class="hljs-comment">// 初始化事件处理Handler,优先使用当前线程Looper</span>
        <span class="hljs-comment">// 如果当前线程没有Looper则使用主线程Looper</span>
        Looper looper;
        <span class="hljs-keyword">if</span> ((looper = Looper.myLooper()) != <span class="hljs-literal">null</span>) {
            mEventHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHandler</span>(<span class="hljs-built_in">this</span>, looper);
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((looper = Looper.getMainLooper()) != <span class="hljs-literal">null</span>) {
            mEventHandler = <span class="hljs-keyword">new</span> <span class="hljs-title class_">EventHandler</span>(<span class="hljs-built_in">this</span>, looper);
        } <span class="hljs-keyword">else</span> {
            mEventHandler = <span class="hljs-literal">null</span>;
        }

        <span class="hljs-comment">// 创建TimeProvider对象用于管理媒体播放时间戳和同步</span>
        mTimeProvider = <span class="hljs-keyword">new</span> <span class="hljs-title class_">TimeProvider</span>(<span class="hljs-built_in">this</span>);
        <span class="hljs-comment">// 创建字幕源输入流列表,用于管理外挂字幕文件</span>
        mOpenSubtitleSources = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vector</span>&lt;InputStream&gt;();

        <span class="hljs-comment">// 获取Attribution信息,包含调用者身份信息</span>
        <span class="hljs-comment">// 如果context为null则使用默认Attribution</span>
        <span class="hljs-type">AttributionSource</span> <span class="hljs-variable">attributionSource</span> <span class="hljs-operator">=</span>
                context == <span class="hljs-literal">null</span> ? AttributionSource.myAttributionSource()
                        : context.getAttributionSource();
        <span class="hljs-keyword">if</span> (attributionSource.getPackageName() == <span class="hljs-literal">null</span>) {
            attributionSource = attributionSource.withPackageName(<span class="hljs-string">&quot;&quot;</span>);
        }

        <span class="hljs-comment">// 初始化native层MediaPlayer</span>
        <span class="hljs-keyword">try</span> (<span class="hljs-type">ScopedParcelState</span> <span class="hljs-variable">attributionSourceState</span> <span class="hljs-operator">=</span> attributionSource.asScopedParcelState()) {
            <span class="hljs-comment">// native_setup用于初始化native层MediaPlayer</span>
            <span class="hljs-comment">// 参数1: 将Java层MediaPlayer对象的弱引用传递给native层,避免内存泄漏</span>
            <span class="hljs-comment">// 参数2: attributionSourceState.getParcel()获取包含调用者身份信息的Parcel对象</span>
            <span class="hljs-comment">//        Parcel是Android中用于序列化数据的容器,可以跨进程传输</span>
            <span class="hljs-comment">// 参数3: 解析音频会话ID,用于音频焦点管理</span>
            native_setup(<span class="hljs-keyword">new</span> <span class="hljs-title class_">WeakReference</span>&lt;&gt;(<span class="hljs-built_in">this</span>), attributionSourceState.getParcel(),
                    resolvePlaybackSessionId(context, sessionId));
        }
        
        <span class="hljs-comment">// 注册到音频系统,注册到AudioServer中的mPlaybackMonitor</span>
        baseRegisterPlayer(getAudioSessionId());
    }
</code></pre>
<pre><code class="language-c++">android_media_MediaPlayer.<span class="hljs-function">cpp
<span class="hljs-title">android_media_MediaPlayer_native_setup</span><span class="hljs-params">(JNIEnv *env, jobject thiz, jobject weak_this,
                                       jobject jAttributionSource,
                                       jint jAudioSessionId)</span>
</span>{
    sp&lt;MediaPlayer&gt; mp = sp&lt;MediaPlayer&gt;::<span class="hljs-built_in">make</span>(
        attributionSource, <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">audio_session_t</span>&gt;(jAudioSessionId));
    <span class="hljs-comment">// create new listener and give it to MediaPlayer</span>
    sp&lt;JNIMediaPlayerListener&gt; listener = <span class="hljs-keyword">new</span> <span class="hljs-built_in">JNIMediaPlayerListener</span>(env, thiz, weak_this);
    mp-&gt;<span class="hljs-built_in">setListener</span>(listener);
    <span class="hljs-comment">// Stow our new C++ MediaPlayer in an opaque field in the Java object.</span>
    <span class="hljs-comment">// 将native层MediaPlayer对象保存到Java层MediaPlayer的mNativeContext成员变量中</span>

    <span class="hljs-built_in">setMediaPlayer</span>(env, thiz, mp);
}

MediaPlayer::<span class="hljs-built_in">MediaPlayer</span>(<span class="hljs-type">const</span> AttributionSourceState&amp; attributionSource,
    <span class="hljs-type">const</span> <span class="hljs-type">audio_session_t</span> sessionId) : <span class="hljs-built_in">mAttributionSource</span>(attributionSource)
{
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;constructor&quot;</span>);
    mListener = <span class="hljs-literal">NULL</span>;
    mCookie = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">//默认赋值AUDIO_STREAM_MUSIC</span>
    mStreamType = AUDIO_STREAM_MUSIC;
    <span class="hljs-comment">//mediaplay初始状态</span>
    mCurrentState = MEDIA_PLAYER_IDLE;
    mPrepareSync = <span class="hljs-literal">false</span>;
    <span class="hljs-keyword">if</span> (sessionId == AUDIO_SESSION_ALLOCATE) {
        <span class="hljs-comment">//在AF中获取一个唯一的mAudioSessionId</span>
        mAudioSessionId = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">audio_session_t</span>&gt;(
            AudioSystem::<span class="hljs-built_in">newAudioUniqueId</span>(AUDIO_UNIQUE_ID_USE_SESSION));
    } <span class="hljs-keyword">else</span> {
        mAudioSessionId = sessionId;
    }
    <span class="hljs-comment">//在AF中记录在mAudioSessionRefs中，大概浏览了一下这个SessionId之后可能跟音效的操作有关</span>
    AudioSystem::<span class="hljs-built_in">acquireAudioSessionId</span>(mAudioSessionId, (<span class="hljs-type">pid_t</span>)<span class="hljs-number">-1</span>, (<span class="hljs-type">uid_t</span>)<span class="hljs-number">-1</span>); <span class="hljs-comment">// always in client.</span>
    mSendLevel = <span class="hljs-number">0</span>;
    mRetransmitEndpointValid = <span class="hljs-literal">false</span>;
}

</code></pre>
<h4 id="总结">总结</h4>
<p>构造流程其实就是完成了一些对象的创建比如TimeProvider、InputStream，然后生成一个AudioSession设置到AF中。</p>
<h3 id="setdatasource">SetDataSource</h3>
<p>我们这里分析参数是网址的情况</p>
<pre><code class="language-java">    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setDataSource</span><span class="hljs-params">(String path, String[] keys, String[] values,
            List&lt;HttpCookie&gt; cookies)</span>
            <span class="hljs-keyword">throws</span> IOException, IllegalArgumentException, SecurityException, IllegalStateException {
        <span class="hljs-keyword">final</span> <span class="hljs-type">Uri</span> <span class="hljs-variable">uri</span> <span class="hljs-operator">=</span> Uri.parse(path);
        <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">scheme</span> <span class="hljs-operator">=</span> uri.getScheme();
        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;file&quot;</span>.equals(scheme)) {
            path = uri.getPath();
        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (scheme != <span class="hljs-literal">null</span>) {
            <span class="hljs-comment">// handle non-file sources</span>
            nativeSetDataSource(
                MediaHTTPService.createHttpServiceBinderIfNecessary(path, cookies),
                path,
                keys,
                values);
            <span class="hljs-keyword">return</span>;
        }

        <span class="hljs-keyword">final</span> <span class="hljs-type">File</span> <span class="hljs-variable">file</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(path);
        <span class="hljs-keyword">try</span> (<span class="hljs-type">FileInputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">FileInputStream</span>(file)) {
            setDataSource(is.getFD());
        }
    }
</code></pre>
<pre><code class="language-c++">android_media_MediaPlayer.<span class="hljs-function">cpp
<span class="hljs-type">static</span> <span class="hljs-type">void</span>
<span class="hljs-title">android_media_MediaPlayer_setDataSourceAndHeaders</span><span class="hljs-params">(
        JNIEnv *env, jobject thiz, jobject httpServiceBinderObj, jstring path,
        jobjectArray keys, jobjectArray values)</span> </span>{

    sp&lt;MediaPlayer&gt; mp = <span class="hljs-built_in">getMediaPlayer</span>(env, thiz);

    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *tmp = env-&gt;<span class="hljs-built_in">GetStringUTFChars</span>(path, <span class="hljs-literal">NULL</span>);
    <span class="hljs-function">String8 <span class="hljs-title">pathStr</span><span class="hljs-params">(tmp)</span></span>;
    env-&gt;<span class="hljs-built_in">ReleaseStringUTFChars</span>(path, tmp);
    tmp = <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">// 将Java层传入的HTTP请求头键值对数组转换为KeyedVector</span>
    <span class="hljs-comment">// headersVector用于存储HTTP请求头信息,比如:</span>
    <span class="hljs-comment">// User-Agent: MediaPlayer</span>
    <span class="hljs-comment">// Accept: */*</span>
    <span class="hljs-comment">// Connection: Keep-Alive </span>
    <span class="hljs-comment">// 等HTTP标准请求头</span>
    <span class="hljs-comment">//该例子是null</span>
    KeyedVector&lt;String8, String8&gt; headersVector;
    <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">ConvertKeyValueArraysToKeyedVector</span>(
            env, keys, values, &amp;headersVector)) {
        <span class="hljs-keyword">return</span>;
    }

    sp&lt;IMediaHTTPService&gt; httpService;
    <span class="hljs-keyword">if</span> (httpServiceBinderObj != <span class="hljs-literal">NULL</span>) {
        sp&lt;IBinder&gt; binder = <span class="hljs-built_in">ibinderForJavaObject</span>(env, httpServiceBinderObj);
        httpService = <span class="hljs-built_in">interface_cast</span>&lt;IMediaHTTPService&gt;(binder);
    }

    <span class="hljs-type">status_t</span> opStatus =
        mp-&gt;<span class="hljs-built_in">setDataSource</span>(
                httpService,
                pathStr.<span class="hljs-built_in">c_str</span>(),
                headersVector.<span class="hljs-built_in">size</span>() &gt; <span class="hljs-number">0</span>? &amp;headersVector : <span class="hljs-literal">NULL</span>);

    <span class="hljs-built_in">process_media_player_call</span>(
            env, thiz, opStatus, <span class="hljs-string">&quot;java/io/IOException&quot;</span>,
            <span class="hljs-string">&quot;setDataSource failed.&quot;</span> );
}
</code></pre>
<pre><code class="language-c++">mediaplayer.<span class="hljs-function">cpp
<span class="hljs-type">status_t</span> <span class="hljs-title">MediaPlayer::setDataSource</span><span class="hljs-params">(
        <span class="hljs-type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url, <span class="hljs-type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span>
</span>{
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSource(%s)&quot;</span>, url);
    <span class="hljs-type">status_t</span> err = BAD_VALUE;
    <span class="hljs-keyword">if</span> (url != <span class="hljs-literal">NULL</span>) {
        <span class="hljs-function"><span class="hljs-type">const</span> sp&lt;IMediaPlayerService&gt; <span class="hljs-title">service</span><span class="hljs-params">(getMediaPlayerService())</span></span>;
        <span class="hljs-keyword">if</span> (service != <span class="hljs-number">0</span>) {
            <span class="hljs-function">sp&lt;IMediaPlayer&gt; <span class="hljs-title">player</span><span class="hljs-params">(service-&gt;create(<span class="hljs-keyword">this</span>, mAudioSessionId, mAttributionSource))</span></span>;
            <span class="hljs-keyword">if</span> ((NO_ERROR != <span class="hljs-built_in">doSetRetransmitEndpoint</span>(player)) ||
                (NO_ERROR != player-&gt;<span class="hljs-built_in">setDataSource</span>(httpService, url, headers))) {
                player.<span class="hljs-built_in">clear</span>();
            }
            err = <span class="hljs-built_in">attachNewPlayer</span>(player);
        }
    }
    <span class="hljs-keyword">return</span> err;
}
</code></pre>
<pre><code class="language-c++">MediaPlayerService.<span class="hljs-function">cpp
sp&lt;IMediaPlayer&gt; <span class="hljs-title">MediaPlayerService::create</span><span class="hljs-params">(<span class="hljs-type">const</span> sp&lt;IMediaPlayerClient&gt;&amp; client,
        <span class="hljs-type">audio_session_t</span> audioSessionId, <span class="hljs-type">const</span> AttributionSourceState&amp; attributionSource)</span>
</span>{
    <span class="hljs-type">int32_t</span> connId = <span class="hljs-built_in">android_atomic_inc</span>(&amp;mNextConnId);
    <span class="hljs-comment">// TODO b/182392769: use attribution source util</span>
    AttributionSourceState verifiedAttributionSource = attributionSource;
    verifiedAttributionSource.pid = <span class="hljs-built_in">VALUE_OR_FATAL</span>(
        <span class="hljs-built_in">legacy2aidl_pid_t_int32_t</span>(IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">getCallingPid</span>()));
    verifiedAttributionSource.uid = <span class="hljs-built_in">VALUE_OR_FATAL</span>(
        <span class="hljs-built_in">legacy2aidl_uid_t_int32_t</span>(IPCThreadState::<span class="hljs-built_in">self</span>()-&gt;<span class="hljs-built_in">getCallingUid</span>()));
        <span class="hljs-comment">//Client 集成BnMediaPlayer</span>
    sp&lt;Client&gt; c = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Client</span>(
            <span class="hljs-keyword">this</span>, verifiedAttributionSource, connId, client, audioSessionId);

    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;Create new client(%d) from %s, &quot;</span>, connId,
        verifiedAttributionSource.<span class="hljs-built_in">toString</span>().<span class="hljs-built_in">c_str</span>());
    <span class="hljs-comment">//算是记录一下有哪些mediaplayer，注意这里使用弱指针。</span>
    wp&lt;Client&gt; w = c;
    {
        <span class="hljs-function">Mutex::Autolock <span class="hljs-title">lock</span><span class="hljs-params">(mLock)</span></span>;
        mClients.<span class="hljs-built_in">add</span>(w);
    }
    <span class="hljs-keyword">return</span> c;
}
</code></pre>
<pre><code class="language-c++"><span class="hljs-type">status_t</span> MediaPlayerService::Client::<span class="hljs-built_in">setDataSource</span>(
        <span class="hljs-type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,
        <span class="hljs-type">const</span> KeyedVector&lt;String8, String8&gt; *headers)
{
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSource(%s)&quot;</span>, url);
    <span class="hljs-keyword">if</span> (url == <span class="hljs-literal">NULL</span>)
        <span class="hljs-keyword">return</span> UNKNOWN_ERROR;

    <span class="hljs-keyword">if</span> ((<span class="hljs-built_in">strncmp</span>(url, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>) ||
        (<span class="hljs-built_in">strncmp</span>(url, <span class="hljs-string">&quot;https://&quot;</span>, <span class="hljs-number">8</span>) == <span class="hljs-number">0</span>) ||
        (<span class="hljs-built_in">strncmp</span>(url, <span class="hljs-string">&quot;rtsp://&quot;</span>, <span class="hljs-number">7</span>) == <span class="hljs-number">0</span>)) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">checkPermission</span>(<span class="hljs-string">&quot;android.permission.INTERNET&quot;</span>)) {
            <span class="hljs-keyword">return</span> PERMISSION_DENIED;
        }
    }

<span class="hljs-comment">//ContentProvider是Android系统中四大组件之一，用于在不同应用之间安全地共享数据</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strncmp</span>(url, <span class="hljs-string">&quot;content://&quot;</span>, <span class="hljs-number">10</span>) == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">// get a filedescriptor for the content Uri and</span>
        <span class="hljs-comment">// pass it to the setDataSource(fd) method</span>

        <span class="hljs-function">String16 <span class="hljs-title">url16</span><span class="hljs-params">(url)</span></span>;
        <span class="hljs-type">int</span> fd = android::<span class="hljs-built_in">openContentProviderFile</span>(url16);
        <span class="hljs-keyword">if</span> (fd &lt; <span class="hljs-number">0</span>)
        {
            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Couldn&#x27;t open fd for %s&quot;</span>, url);
            <span class="hljs-keyword">return</span> UNKNOWN_ERROR;
        }
        <span class="hljs-type">status_t</span> status = <span class="hljs-built_in">setDataSource</span>(fd, <span class="hljs-number">0</span>, <span class="hljs-number">0x7fffffffff</span>LL); <span class="hljs-comment">// this sets mStatus</span>
        <span class="hljs-built_in">close</span>(fd);
        <span class="hljs-keyword">return</span> mStatus = status;
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">//获取player的种类，目前只有nuplayer、testplayer </span>
        <span class="hljs-comment">//获取哪种的方法 时使用打分制度来评比的，看哪种player更适合当前的url</span>
        player_type playerType = MediaPlayerFactory::<span class="hljs-built_in">getPlayerType</span>(<span class="hljs-keyword">this</span>, url);
        sp&lt;MediaPlayerBase&gt; p = <span class="hljs-built_in">setDataSource_pre</span>(playerType);
        <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) {
            <span class="hljs-keyword">return</span> NO_INIT;
        }

        <span class="hljs-keyword">return</span> mStatus =
                <span class="hljs-built_in">setDataSource_post</span>(
                p, p-&gt;<span class="hljs-built_in">setDataSource</span>(httpService, url, headers));
    }
} 
</code></pre>
<h4 id="mediaplayerservicecpp-setdatasource_pre">MediaPlayerService.cpp setDataSource_pre</h4>
<pre><code class="language-c++"><span class="hljs-comment">// setDataSource_pre函数主要完成以下工作:</span>
sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::<span class="hljs-built_in">setDataSource_pre</span>(player_type playerType) {
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;player type = %d&quot;</span>, playerType);

    <span class="hljs-comment">// 1. 根据playerType创建对应的播放器实例(NuPlayer或TestPlayer)</span>
    sp&lt;MediaPlayerBase&gt; p = <span class="hljs-built_in">createPlayer</span>(playerType);
    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-keyword">return</span> p;
    }

    std::vector&lt;DeathNotifier&gt; deathNotifiers;

    <span class="hljs-comment">// 2. 监听media.extractor服务的死亡通知</span>
    <span class="hljs-comment">// 3. 监听OMX服务的死亡通知</span>
    <span class="hljs-comment">// 4. 监听所有Codec2服务的死亡通知</span>
    <span class="hljs-comment">// 5. 更新死亡通知列表</span>
    mDeathNotifiers.<span class="hljs-built_in">clear</span>();
    mDeathNotifiers.<span class="hljs-built_in">swap</span>(deathNotifiers);
    <span class="hljs-comment">// 6. 创建音频设备更新监听器</span>
    mAudioDeviceUpdatedListener = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AudioDeviceUpdatedNotifier</span>(p);

    <span class="hljs-comment">// 7. 如果不是硬件输出,创建音频输出并设置音频接收器</span>
    <span class="hljs-keyword">if</span> (!p-&gt;<span class="hljs-built_in">hardwareOutput</span>()) {
        mAudioOutput = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AudioOutput</span>(mAudioSessionId, mAttributionSource, mAudioAttributes,
                                       mAudioDeviceUpdatedListener);
        <span class="hljs-built_in">static_cast</span>&lt;MediaPlayerInterface*&gt;(p.<span class="hljs-built_in">get</span>())-&gt;<span class="hljs-built_in">setAudioSink</span>(mAudioOutput);
    }

    <span class="hljs-keyword">return</span> p;
}

sp&lt;MediaPlayerBase&gt; MediaPlayerService::Client::<span class="hljs-built_in">createPlayer</span>(player_type playerType) {
    <span class="hljs-comment">// determine if we have the right player type</span>
    sp&lt;MediaPlayerBase&gt; p = <span class="hljs-built_in">getPlayer</span>();

    <span class="hljs-keyword">if</span> (p == <span class="hljs-literal">NULL</span>) {
        <span class="hljs-comment">//该函数会根据playerType找对对应的playerfactory类调用对应的createPlayer</span>
        p = MediaPlayerFactory::<span class="hljs-built_in">createPlayer</span>(
                playerType, mListener,
                <span class="hljs-built_in">VALUE_OR_FATAL</span>(<span class="hljs-built_in">aidl2legacy_int32_t_pid_t</span>(mAttributionSource.pid)));
    }
    <span class="hljs-keyword">return</span> p;
}
<span class="hljs-comment">//MediaPlayerFactory.cpp 中的NuPlayerFactory</span>
<span class="hljs-comment">//先分析到这里 ，之后在深入分析NuPlayerDriver做了什么</span>
<span class="hljs-function"><span class="hljs-keyword">virtual</span> sp&lt;MediaPlayerBase&gt; <span class="hljs-title">createPlayer</span><span class="hljs-params">(<span class="hljs-type">pid_t</span> pid)</span> </span>{
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot; create NuPlayer&quot;</span>);
        <span class="hljs-comment">//这个pid应该是app的 进程号</span>
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">NuPlayerDriver</span>(pid);
    }
</code></pre>
<h4 id="nuplayerdriver">NuPlayerDriver</h4>
<pre><code class="language-C++">NuPlayerDriver::<span class="hljs-built_in">NuPlayerDriver</span>(<span class="hljs-type">pid_t</span> pid)
    : <span class="hljs-built_in">mState</span>(STATE_IDLE),
      <span class="hljs-built_in">mIsAsyncPrepare</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mAsyncResult</span>(UNKNOWN_ERROR),
      <span class="hljs-built_in">mSetSurfaceInProgress</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mDurationUs</span>(<span class="hljs-number">-1</span>),
      <span class="hljs-built_in">mPositionUs</span>(<span class="hljs-number">-1</span>),
      <span class="hljs-built_in">mSeekInProgress</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mPlayingTimeUs</span>(<span class="hljs-number">0</span>),
      <span class="hljs-built_in">mRebufferingTimeUs</span>(<span class="hljs-number">0</span>),
      <span class="hljs-built_in">mRebufferingEvents</span>(<span class="hljs-number">0</span>),
      <span class="hljs-built_in">mRebufferingAtExit</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mLooper</span>(<span class="hljs-keyword">new</span> ALooper),
      <span class="hljs-built_in">mMediaClock</span>(<span class="hljs-keyword">new</span> MediaClock),
      <span class="hljs-built_in">mPlayer</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">NuPlayer</span>(pid, mMediaClock)),
      <span class="hljs-built_in">mPlayerFlags</span>(<span class="hljs-number">0</span>),
      <span class="hljs-built_in">mCachedPlayerIId</span>(PLAYER_PIID_INVALID),
      <span class="hljs-built_in">mMetricsItem</span>(<span class="hljs-literal">NULL</span>),
      <span class="hljs-built_in">mClientUid</span>(<span class="hljs-number">-1</span>),
      <span class="hljs-built_in">mAtEOS</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mLooping</span>(<span class="hljs-literal">false</span>),
      <span class="hljs-built_in">mAutoLoop</span>(<span class="hljs-literal">false</span>) {
    <span class="hljs-built_in">ALOGD</span>(<span class="hljs-string">&quot;NuPlayerDriver(%p) created, clientPid(%d)&quot;</span>, <span class="hljs-keyword">this</span>, pid);
    mLooper-&gt;<span class="hljs-built_in">setName</span>(<span class="hljs-string">&quot;NuPlayerDriver Looper&quot;</span>);

    mMediaClock-&gt;<span class="hljs-built_in">init</span>();

    <span class="hljs-comment">// set up an analytics record</span>
    mMetricsItem = mediametrics::Item::<span class="hljs-built_in">create</span>(kKeyPlayer);

    mLooper-&gt;<span class="hljs-built_in">start</span>(
            <span class="hljs-literal">false</span>, <span class="hljs-comment">/* runOnCallingThread */</span>
            <span class="hljs-literal">true</span>,  <span class="hljs-comment">/* canCallJava */</span>
            PRIORITY_AUDIO);

    mLooper-&gt;<span class="hljs-built_in">registerHandler</span>(mPlayer);
    <span class="hljs-comment">//会调用到Nuplayer.init中</span>
    mPlayer-&gt;<span class="hljs-built_in">init</span>(<span class="hljs-keyword">this</span>);
}
</code></pre>
<h4 id="nuplayerdrivercpp-setdatasource">NuPlayerDriver.cpp setDataSource</h4>
<pre><code class="language-c++"><span class="hljs-function"><span class="hljs-type">status_t</span> <span class="hljs-title">NuPlayerDriver::setDataSource</span><span class="hljs-params">(
        <span class="hljs-type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,
        <span class="hljs-type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span> </span>{
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSource(%p) url(%s)&quot;</span>, <span class="hljs-keyword">this</span>, <span class="hljs-built_in">uriDebugString</span>(url, <span class="hljs-literal">false</span>).<span class="hljs-built_in">c_str</span>());
    <span class="hljs-built_in">ATRACE_BEGIN</span>(<span class="hljs-built_in">StringPrintf</span>(<span class="hljs-string">&quot;setDataSource(%p)&quot;</span>, <span class="hljs-keyword">this</span>).<span class="hljs-built_in">c_str</span>());
    <span class="hljs-function">Mutex::Autolock <span class="hljs-title">autoLock</span><span class="hljs-params">(mLock)</span></span>;

    <span class="hljs-keyword">if</span> (mState != STATE_IDLE) {
        <span class="hljs-built_in">ATRACE_END</span>();
        <span class="hljs-keyword">return</span> INVALID_OPERATION;
    }
    <span class="hljs-comment">//设置状态 media中状态很重要</span>
    mState = STATE_SET_DATASOURCE_PENDING;

    mPlayer-&gt;<span class="hljs-built_in">setDataSourceAsync</span>(httpService, url, headers);
    <span class="hljs-comment">//通过while循环来模拟同步</span>
    <span class="hljs-keyword">while</span> (mState == STATE_SET_DATASOURCE_PENDING) {
        mCondition.<span class="hljs-built_in">wait</span>(mLock);
    }
    <span class="hljs-built_in">ATRACE_END</span>();

    <span class="hljs-keyword">return</span> mAsyncResult;
}
</code></pre>
<h4 id="nuplayercpp-setdatasourceaync">NuPlayer.cpp setDataSourceAync</h4>
<pre><code class="language-c++"><span class="hljs-comment">// NuPlayer::setDataSourceAsync 函数分析</span>
<span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">NuPlayer::setDataSourceAsync</span><span class="hljs-params">(
        <span class="hljs-type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService, <span class="hljs-comment">// HTTP服务</span>
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,                         <span class="hljs-comment">// 媒体文件URL</span>
        <span class="hljs-type">const</span> KeyedVector&lt;String8, String8&gt; *headers)</span> </span>{ <span class="hljs-comment">// HTTP头部信息</span>

    <span class="hljs-comment">// 创建一个消息,类型为kWhatSetDataSource</span>
    sp&lt;AMessage&gt; msg = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AMessage</span>(kWhatSetDataSource, <span class="hljs-keyword">this</span>);
    <span class="hljs-type">size_t</span> len = <span class="hljs-built_in">strlen</span>(url);

    <span class="hljs-comment">// 创建一个通知消息,用于Source回调通知</span>
    sp&lt;AMessage&gt; notify = <span class="hljs-keyword">new</span> <span class="hljs-built_in">AMessage</span>(kWhatSourceNotify, <span class="hljs-keyword">this</span>);

    <span class="hljs-comment">// 根据URL类型创建不同的Source对象</span>
    sp&lt;Source&gt; source;
    
    <span class="hljs-comment">// 1. 如果是HTTP Live流(m3u8)</span>
    <span class="hljs-comment">// m3u8是HTTP Live Streaming(HLS)协议的媒体播放列表文件</span>
    <span class="hljs-comment">// HLS协议将媒体内容切分成小片段(.ts文件)</span>
    <span class="hljs-comment">// m3u8文件包含了这些媒体片段的索引信息</span>
    <span class="hljs-comment">// 客户端可以通过HTTP协议下载m3u8和对应的媒体片段进行播放</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">IsHTTPLiveURL</span>(url)) {
        source = <span class="hljs-keyword">new</span> <span class="hljs-built_in">HTTPLiveSource</span>(notify, httpService, url, headers);
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSourceAsync HTTPLiveSource %s&quot;</span>, url);
        mDataSourceType = DATA_SOURCE_TYPE_HTTP_LIVE;
    } 
    <span class="hljs-comment">// 2. 如果是RTSP流</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-built_in">strncasecmp</span>(url, <span class="hljs-string">&quot;rtsp://&quot;</span>, <span class="hljs-number">7</span>)) {
        source = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RTSPSource</span>(
                notify, httpService, url, headers, mUIDValid, mUID);
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSourceAsync RTSPSource %s&quot;</span>, url);
        mDataSourceType = DATA_SOURCE_TYPE_RTSP;
    }
    <span class="hljs-comment">// 3. 如果是HTTP/HTTPS的SDP文件(也是RTSP流)</span>
    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((!<span class="hljs-built_in">strncasecmp</span>(url, <span class="hljs-string">&quot;http://&quot;</span>, <span class="hljs-number">7</span>)
                || !<span class="hljs-built_in">strncasecmp</span>(url, <span class="hljs-string">&quot;https://&quot;</span>, <span class="hljs-number">8</span>))
                    &amp;&amp; ((len &gt;= <span class="hljs-number">4</span> &amp;&amp; !<span class="hljs-built_in">strcasecmp</span>(<span class="hljs-string">&quot;.sdp&quot;</span>, &amp;url[len - <span class="hljs-number">4</span>]))
                    || <span class="hljs-built_in">strstr</span>(url, <span class="hljs-string">&quot;.sdp?&quot;</span>))) {
        source = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RTSPSource</span>(
                notify, httpService, url, headers, mUIDValid, mUID, <span class="hljs-literal">true</span>);
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSourceAsync RTSPSource http/https/.sdp %s&quot;</span>, url);
        mDataSourceType = DATA_SOURCE_TYPE_RTSP;
    }
    <span class="hljs-comment">// 4. 其他普通URL(如本地文件、HTTP普通文件等)</span>
    <span class="hljs-keyword">else</span> {
        <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSourceAsync GenericSource %s&quot;</span>, url);

        <span class="hljs-comment">// 创建通用Source</span>
        sp&lt;GenericSource&gt; genericSource =
                <span class="hljs-keyword">new</span> <span class="hljs-built_in">GenericSource</span>(notify, mUIDValid, mUID, mMediaClock);

        <span class="hljs-comment">// 设置数据源</span>
        <span class="hljs-type">status_t</span> err = genericSource-&gt;<span class="hljs-built_in">setDataSource</span>(httpService, url, headers);

        <span class="hljs-keyword">if</span> (err == OK) {
            source = genericSource;
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-built_in">ALOGE</span>(<span class="hljs-string">&quot;Failed to set data source!&quot;</span>);
        }

        mDataSourceType = DATA_SOURCE_TYPE_GENERIC_URL;
    }

    <span class="hljs-comment">// 将创建的Source对象设置到消息中并发送</span>
    msg-&gt;<span class="hljs-built_in">setObject</span>(<span class="hljs-string">&quot;source&quot;</span>, source);
    msg-&gt;<span class="hljs-built_in">post</span>();
}
```setDataSourceAsync
#### GenericSource.cpp setDataSource
```c++
<span class="hljs-type">status_t</span> NuPlayer::GenericSource::<span class="hljs-built_in">setDataSource</span>(
        <span class="hljs-type">const</span> sp&lt;IMediaHTTPService&gt; &amp;httpService,
        <span class="hljs-type">const</span> <span class="hljs-type">char</span> *url,
        <span class="hljs-type">const</span> KeyedVector&lt;String8, String8&gt; *headers) {
    Mutex::Autolock _l(mLock);
    <span class="hljs-built_in">ALOGV</span>(<span class="hljs-string">&quot;setDataSource url: %s&quot;</span>, url);

    <span class="hljs-built_in">resetDataSource</span>();

    mHTTPService = httpService;
    mUri = url;

    <span class="hljs-keyword">if</span> (headers) {
        mUriHeaders = *headers;
    }
    <span class="hljs-keyword">return</span> OK;
}
</code></pre>
<h3 id="setdatasource-流程总结">SetDataSource 流程总结</h3>
<p><code>setDataSource</code> 的整个流程横跨了Java应用层、JNI、C++客户端框架以及服务端的MediaPlayerService，最终由具体的播放器引擎（如NuPlayer）执行。其核心思想是：<strong>通过Binder机制将客户端的同步调用转化为服务端的异步处理，并在服务端通过同步阻塞的方式等待异步操作完成</strong>。</p>
<h4 id="1-应用层到客户端-java---jni---c">1. 应用层到客户端 (Java -&gt; JNI -&gt; C++)</h4>
<ul>
<li>Java层的 <code>MediaPlayer.setDataSource(String path, ...)</code> 方法根据URL协议类型（如http/https）调用到JNI层的 <code>nativeSetDataSource</code>。</li>
<li>JNI层 (<code>android_media_MediaPlayer.cpp</code>) 将Java数据类型转换为C++类型，然后调用C++ <code>MediaPlayer</code> 对象的 <code>setDataSource</code> 方法。</li>
</ul>
<h4 id="2-客户端到服务端-mediaplayer---mediaplayerservice">2. 客户端到服务端 (MediaPlayer -&gt; MediaPlayerService)</h4>
<ul>
<li>C++ <code>MediaPlayer</code> 首先通过 <code>getMediaPlayerService()</code> 获取到 <code>MediaPlayerService</code> 的Binder代理。</li>
<li>调用 <code>service-&gt;create()</code> 请求 <code>MediaPlayerService</code> 创建一个播放器实例。<code>MediaPlayerService</code> 会创建一个 <code>MediaPlayerService::Client</code> 对象（它本身是一个Binder服务端），并将其返回给客户端。</li>
<li>客户端拿到这个 <code>Client</code> 的代理后，调用其 <code>setDataSource</code> 方法，这是一次跨进程的Binder调用，将请求发送到 <code>mediaserver</code> 进程。</li>
</ul>
<h4 id="3-服务端分发-mediaplayerserviceclient">3. 服务端分发 (MediaPlayerService::Client)</h4>
<ul>
<li><code>MediaPlayerService::Client</code> 接收到 <code>setDataSource</code> 请求后，首先进行权限检查。</li>
<li>通过 <code>MediaPlayerFactory::getPlayerType</code> 判断应该使用哪种播放器（通常是 <code>NuPlayer</code>）。</li>
<li>调用 <code>createPlayer</code> 方法，通过 <code>NuPlayerFactory</code> 创建一个 <code>NuPlayerDriver</code> 实例。<code>NuPlayerDriver</code> 在其构造函数中会创建核心的 <code>NuPlayer</code> 对象和一个 <code>ALooper</code> 消息循环线程。</li>
<li>最后，调用 <code>NuPlayerDriver</code> 的 <code>setDataSource</code> 方法。</li>
</ul>
<h4 id="4-同步接口与异步实现-nuplayerdriver---nuplayer">4. 同步接口与异步实现 (NuPlayerDriver -&gt; NuPlayer)</h4>
<ul>
<li><code>NuPlayerDriver::setDataSource</code> 是一个 <strong>同步阻塞</strong> 的接口。它将自身状态设置为 <code>STATE_SET_DATASOURCE_PENDING</code>。</li>
<li>它调用 <code>NuPlayer::setDataSourceAsync</code> 发起 <strong>异步</strong> 请求。</li>
<li><code>NuPlayer::setDataSourceAsync</code> 内部会根据URL创建对应的 <code>Source</code>（如<code>GenericSource</code>、<code>HTTPLiveSource</code>等），然后将这个 <code>Source</code> 对象包装在一个 <code>AMessage</code> 消息中，通过 <code>msg-&gt;post()</code> 发送到 <code>NuPlayer</code> 内部的 <code>ALooper</code> 线程进行处理，然后立即返回。</li>
<li><code>NuPlayerDriver</code> 在调用完异步方法后，会立刻在 <code>while</code> 循环中调用 <code>mCondition.wait(mLock)</code> <strong>阻塞等待</strong>，直到 <code>NuPlayer</code> 的异步操作完成并通过回调通知它。</li>
</ul>
<h4 id="5-异步处理与完成通知">5. 异步处理与完成通知</h4>
<ul>
<li><code>NuPlayer</code> 的 <code>ALooper</code> 线程收到消息后，在 <code>onMessageReceived</code> 中处理 <code>kWhatSetDataSource</code> 消息，开始真正的数据源准备工作。</li>
<li>当异步操作完成后，<code>NuPlayer</code> 会回调 <code>NuPlayerDriver</code> 的 <code>notifySetDataSourceCompleted</code> 方法。</li>
<li><code>NuPlayerDriver</code> 在这个回调中，将 <code>mState</code> 修改为完成状态，并调用 <code>mCondition.signal()</code> <strong>唤醒</strong> 之前阻塞的线程。</li>
<li><code>setDataSource</code> 调用至此完成，并逐层返回结果给应用。</li>
</ul>
<pre><code class="language-mermaid">sequenceDiagram
    participant App as 应用进程
    participant MP as MediaPlayer
    participant MPS as MediaPlayerService
    participant Client as MPS::Client
    participant NPD as NuPlayerDriver
    participant NP as NuPlayer
    participant Source as Source(HTTP/RTSP/Generic)
    
    App-&gt;&gt;MP: setDataSource(url)
    MP-&gt;&gt;MPS: getMediaPlayerService()
    MP-&gt;&gt;MPS: service-&gt;create()
    MPS-&gt;&gt;Client: new Client()
    MP-&gt;&gt;Client: player-&gt;setDataSource()
    Client-&gt;&gt;Client: getPlayerType()
    Client-&gt;&gt;Client: setDataSource_pre()
    Client-&gt;&gt;NPD: createPlayer(playerType)
    NPD-&gt;&gt;NP: new NuPlayer()
    Client-&gt;&gt;NPD: p-&gt;setDataSource()
    
    NPD-&gt;&gt;NPD: mState = STATE_SET_DATASOURCE_PENDING
    NPD-&gt;&gt;NP: setDataSourceAsync(url)
    
    Note over NP: 创建消息对象
    NP-&gt;&gt;NP: msg = new AMessage(kWhatSetDataSource)
    NP-&gt;&gt;NP: notify = new AMessage(kWhatSourceNotify)
    
    alt HTTP Live流
        NP-&gt;&gt;Source: new HTTPLiveSource()
    else RTSP流
        NP-&gt;&gt;Source: new RTSPSource()
    else HTTP/SDP文件
        NP-&gt;&gt;Source: new RTSPSource(sdp=true)
    else 普通URL
        NP-&gt;&gt;Source: new GenericSource()
        Source-&gt;&gt;Source: setDataSource(url)
    end
    
    NP-&gt;&gt;NP: msg-&gt;setObject(&quot;source&quot;, source)
    NP-&gt;&gt;NP: msg-&gt;post()
    
    Note over NP: 稍后在NuPlayer线程处理消息
    NP-&gt;&gt;NP: onMessageReceived(kWhatSetDataSource)
    NP-&gt;&gt;NPD: notifySetDataSourceCompleted()
    
    NPD-&gt;&gt;NPD: mState = STATE_UNPREPARED
    NPD-&gt;&gt;NPD: mCondition.signal()
    
    Note over NPD: 唤醒等待的线程
    NPD-&gt;&gt;MP: 返回结果
    MP-&gt;&gt;App: 返回结果
</code></pre>
<h3 id="prepareasyncprepare">PrepareAsync/Prepare</h3>
<h3 id="start">Start</h3>
<h3 id="pausestop">Pause/Stop</h3>
<h3 id="release">Release</h3>

            
            
        </body>
        </html>