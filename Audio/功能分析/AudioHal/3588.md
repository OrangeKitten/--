# 3588项目AudioHal代码分析文档

## 概述

本文档详细分析了3588项目的AudioHal实现，主要包含音频硬件抽象层的核心功能、HFP蓝牙通话协议处理、DSP音频控制等模块。代码基于ALSA音频架构实现，支持多种音频总线和格式。

## 文件结构

```
Audio相关/audiohal/alsa_hal/
├── audio_hw.c          # 主要音频HAL实现
├── audio_hw.h          # 数据结构定义
├── hfp.c              # HFP蓝牙通话协议实现
├── audio_control.cpp  # DSP音频控制
├── audio_control.h    # 音频控制接口定义
└── Android.mk         # 编译配置
```

## 主要数据结构分析

### 1. audio_device 结构体
```c
struct audio_device {
    struct audio_hw_device device;       // 音频硬件设备基类
    audio_devices_t in_device;          // 输入设备类型
    audio_source_t input_source;        // 音频输入源
    audio_channel_mask_t in_channel_mask; // 输入通道掩码
    Hashmap *out_bus_stream_map;        // 输出总线流映射表
    Hashmap *in_bus_tone_frequency_map; // 输入总线音调频率映射表
    pthread_mutex_t lock;               // 设备锁
    audio_patch_handle_t last_patch_id; // 最后音频补丁ID
    bool standby;                       // 待机状态
    bool mic_mute;                      // 麦克风静音状态
    // HFP相关线程
    pthread_t mic_to_bt_source;         // 麦克风到蓝牙源线程
    pthread_t mic_to_bt_sink;           // 麦克风到蓝牙接收线程
    pthread_t bt_to_speaker_source;     // 蓝牙到扬声器源线程
    pthread_t bt_to_speaker_sink;       // 蓝牙到扬声器接收线程
    bool enable_hfp;                    // HFP功能开关
    audio_patch_handle_t btCallAudioPatch;  // 蓝牙通话音频补丁
    audio_patch_handle_t tunerAudioPatch;   // 调谐器音频补丁
    int media_path;                     // 媒体路径
};
```

### 2. stream_out 结构体
```c
struct stream_out {
    struct audio_stream_out stream;     // 输出流基类
    uint32_t sample_rate;              // 采样率
    pthread_mutex_t lock;              // 流锁
    audio_channel_mask_t channel_mask; // 通道掩码
    struct snd_pcm_config config;      // PCM配置
    audio_format_t format;             // 音频格式
    uint32_t period_size;              // 周期大小
    uint32_t period_count;             // 周期数量
    uint64_t written;                  // 已写入帧数
    uint64_t nframes;                  // 当前帧数
    snd_pcm_t *pcm;                   // ALSA PCM句柄
    uint32_t channels;                 // 通道数
    struct audio_device *dev;          // 关联的音频设备
    const char *bus_address;           // 总线地址
    struct audio_gain gain_stage;      // 增益级
    float amplitude_ratio;             // 振幅比
    bool standby;                      // 待机状态
    struct data_dump dump;             // 调试数据转储
};
```

### 3. stream_in 结构体
```c
struct stream_in {
    struct audio_stream_in stream;     // 输入流基类
    audio_channel_mask_t channel_mask; // 通道掩码
    audio_format_t format;             // 音频格式
    uint32_t sample_rate;              // 采样率
    uint32_t requested_rate;           // 请求的采样率
    uint32_t channels;                 // 通道数
    pthread_mutex_t lock;              // 流锁
    bool standby;                      // 待机状态
    size_t frames_in;                  // 输入帧数
    int read_status;                   // 读取状态
    uint64_t frames_read;              // 已读取帧数
    // 重采样相关
    struct resampler_itfe *resampler;  // 重采样器接口
    struct resampler_buffer_provider buf_provider; // 缓冲区提供者
    int16_t *buffer;                   // 音频缓冲区
    // 渐变处理
    uint16_t ramp_vol;                 // 渐变音量
    uint16_t ramp_step;                // 渐变步长
    size_t ramp_frames;                // 渐变帧数
    const char *bus_address;           // 总线地址
    struct data_dump dump;             // 调试数据转储
};
```

## 核心功能模块分析

### 1. PCM配置管理

#### bus_address_to_pcm_config()
**功能**: 根据总线地址选择对应的PCM配置
**实现逻辑**:
- 维护一个地址到PCM配置的映射表，支持多种音频总线：
  - BUS00_MEDIA: 媒体播放总线（32位格式）
  - BUS15_MEDIA_HIFI_712_OUT: 7.1.2高保真输出（10通道）
  - BUS16_MEDIA_HIFI_51_OUT: 5.1环绕声输出（6通道）
  - BUS04_CALL_OUT: 通话输出总线
  - BUS99_BT_UPLINK_OUT: 蓝牙上行输出
  - BUS00_VR_IN: 语音识别输入（12通道）
  - BUS07_BT_DOWNLINK_IN: 蓝牙下行输入
- 默认48kHz采样率，20ms周期时间
- 支持立体声到12通道的多声道配置

#### alsa_pcm_open()
**功能**: 打开ALSA PCM设备并配置硬件参数
**实现逻辑**:
1. 打开指定的PCM设备（播放或录制模式）
2. 分配并初始化硬件参数结构
3. 设置访问模式为交错模式（SND_PCM_ACCESS_RW_INTERLEAVED）
4. 配置音频格式、通道数、采样率
5. 设置缓冲区大小和周期大小
6. 应用硬件参数到驱动
7. 调用set_sw_params()设置软件参数

#### set_sw_params()
**功能**: 设置ALSA PCM的软件参数
**实现逻辑**:
- 设置时间戳模式为启用（SND_PCM_TSTAMP_ENABLE）
- 设置时间戳类型为单调时钟（SND_PCM_TSTAMP_TYPE_MONOTONIC）
- 配置启动阈值、停止阈值和最小可用空间
- 用于控制音频流的启动和停止行为

### 2. 输出流管理

#### start_output_stream()
**功能**: 启动音频输出流
**实现逻辑**:
1. 根据总线地址分配输出设备
2. 检查是否为媒体流，根据通道数设置相应的媒体路径：
   - 2通道: MEDIA_PATH_STEREO
   - 6通道: MEDIA_PATH_SURROUND_5P1
   - 8通道: MEDIA_PATH_SURROUND_7P1
   - 10通道: MEDIA_PATH_SURROUND_7P1P2
   - 12通道: MEDIA_PATH_SURROUND_7P1P4
3. 通过audio_control_set_media_path()设置DSP媒体路径
4. 调用alsa_pcm_open()打开PCM设备

#### out_write()
**功能**: 向输出流写入音频数据
**实现逻辑**:
1. 获取输出流锁
2. 检查待机状态，如需要则启动输出流
3. 调用dump_out_data()进行调试数据转储
4. 使用snd_pcm_writei()写入音频数据
5. 错误处理：
   - -EBADFD: 设备错误，退出
   - -EPIPE: 缓冲区下溢，调用snd_pcm_recover()恢复
   - -ESTRPIPE: 设备挂起，尝试恢复或准备
6. 更新已写入帧数统计

#### out_standby()
**功能**: 将输出流置于待机状态
**实现逻辑**:
- 关闭PCM设备句柄
- 重置帧计数器
- 关闭调试转储文件
- 设置待机标志为true

### 3. 输入流管理

#### in_read()
**功能**: 从输入流读取音频数据
**实现逻辑**:
1. 获取输入流锁
2. 检查待机状态，如需要则启动输入流
3. 调用read_frames()读取音频帧
4. 如果配置了音量渐变，调用in_apply_ramp()应用渐变效果
5. 检查麦克风静音状态，如静音则清零数据缓冲区
6. 错误处理时模拟读取延时并进入待机状态

#### read_frames()
**功能**: 读取指定数量的音频帧
**实现逻辑**:
- 如果配置了重采样器，使用重采样器读取并转换数据
- 否则直接从缓冲区提供者获取数据
- 支持循环读取直到满足所需帧数

#### get_next_buffer()
**功能**: 为重采样器提供下一个音频缓冲区
**实现逻辑**:
1. 如果输入缓冲区为空，调用read_l()从PCM设备读取数据
2. 调用dump_in_data()进行调试数据转储
3. 处理立体声到单声道转换（丢弃右声道）
4. 返回可用的音频数据缓冲区

#### in_apply_ramp()
**功能**: 对输入音频应用音量渐变效果
**实现逻辑**:
- 在录音开始时逐渐增加音量，避免突然的音频变化
- 支持单声道和立体声处理
- 使用16位定点运算进行音量控制

### 4. 设备管理

#### adev_open()
**功能**: 打开音频设备
**实现逻辑**:
1. 设置ALSA错误日志处理函数
2. 使用单例模式管理设备实例
3. 初始化设备锁和各种接口函数指针
4. 创建输出总线流映射表和输入总线音调频率映射表
5. 调用audio_control_init()初始化音频控制模块

#### adev_open_output_stream()
**功能**: 打开输出音频流
**实现逻辑**:
1. 分配stream_out结构体内存
2. 初始化流锁和接口函数指针
3. 根据地址获取PCM配置并调整参数
4. 设置增益控制参数（-32dB到6dB，步长1dB）
5. 将流添加到设备的总线流映射表

#### adev_open_input_stream()
**功能**: 打开输入音频流
**实现逻辑**:
1. 分配stream_in结构体内存
2. 根据地址获取PCM配置
3. 初始化重采样器（如需要）
4. 分配音频缓冲区
5. 设置流参数和接口函数

#### adev_create_audio_patch()
**功能**: 创建音频补丁连接
**实现逻辑**:
1. 支持蓝牙通话音频补丁：
   - 源: BUS07_BT_DOWNLINK_IN
   - 目标: BUS04_CALL_OUT
   - 启用HFP功能
2. 支持调谐器音频补丁：
   - 源: BUS04_TUNER_IN  
   - 目标: BUS00_MEDIA
   - 设置媒体源为TUNER
3. 生成唯一的补丁句柄

#### adev_set_audio_port_config()
**功能**: 设置音频端口增益配置
**实现逻辑**:
1. 根据总线地址查找对应的输出流
2. 计算增益索引和总步数
3. 使用对数函数计算振幅比：10^((minDb + (maxDb - minDb) * gainIndex / totalSteps) / 20)
4. 更新流的振幅比参数

## HFP蓝牙通话模块分析

### 1. HFP流结构
```c
struct hfp_stream {
    snd_pcm_t *source;                  // 音频源设备
    snd_pcm_t *sink;                    // 音频目标设备  
    struct snd_pcm_config source_config; // 源配置
    struct snd_pcm_config sink_config;   // 目标配置
    const char *source_device;          // 源设备名
    const char *sink_device;            // 目标设备名
    bool is_running;                    // 运行状态
    unsigned int rate;                  // 采样率（8kHz/16kHz）
    struct data_dump dump_source;       // 源调试转储
    struct data_dump dump_sink;         // 目标调试转储
    int pipefd[2];                      // 管道文件描述符
};
```

### 2. HFP初始化

#### init_hfp_streams()
**功能**: 初始化HFP音频流
**实现逻辑**:
1. 初始化两个HFP流：
   - mic_to_bt: 麦克风到蓝牙（上行）
   - bt_to_speaker: 蓝牙到扬声器（下行）
2. 根据采样率（8kHz/16kHz）选择对应的PCM配置
3. 设置设备名称：
   - 麦克风源: "pcmin1"
   - 蓝牙输出: "btsco_out_8k"/"btsco_out_16k"
   - 蓝牙输入: "btsco_in_8k"/"btsco_in_16k"
   - 扬声器输出: "BUS04_CALL_OUT"

### 3. HFP线程处理

#### run_hfp_source()
**功能**: HFP源线程，负责从音频源读取数据
**实现逻辑**:
1. 使用snd_pcm_readi()从源设备读取音频数据
2. 调用dump_data()进行调试数据转储
3. 通过管道write()将数据发送给接收线程
4. 错误处理：调用snd_pcm_recover()恢复设备
5. 线程退出时清理资源

#### run_hfp_sink()
**功能**: HFP接收线程，负责向音频目标写入数据
**实现逻辑**:
1. 通过管道read()接收来自源线程的数据
2. 调用dump_data()进行调试数据转储
3. 使用snd_pcm_writei()将数据写入目标设备
4. 错误处理：调用snd_pcm_recover()恢复设备
5. 线程退出时调用snd_pcm_drain()清空缓冲区

#### start_hfp_stream()
**功能**: 启动HFP音频流
**实现逻辑**:
1. 调用alsa_pcm_open()打开源和目标PCM设备
2. 创建管道用于线程间通信
3. 设置线程属性为实时调度（SCHED_FIFO）
4. 创建源和接收线程
5. 设置线程优先级为最高

### 4. HFP参数控制

#### audio_hfp_set_parameters()
**功能**: 设置HFP参数
**实现逻辑**:
1. 处理"hfp_enable"参数：
   - "true": 启动HFP功能，如采样率未设置则延迟启动
   - "false": 停止HFP功能
2. 处理"hfp_set_sampling_rate"参数：
   - 支持8kHz和16kHz采样率
   - 等待HFP线程停止后重新初始化流
   - 如有延迟启动标志则立即启动HFP

#### start_hfp()
**功能**: 启动HFP功能
**实现逻辑**:
1. 检查HFP是否已经激活
2. 启动bt_to_speaker流（下行）
3. 启动mic_to_bt流（上行）
4. 设置enable_hfp标志

#### stop_hfp()
**功能**: 停止HFP功能
**实现逻辑**:
- 设置流运行标志为false
- 清除enable_hfp标志
- 重置采样率和延迟启动标志

## 音频控制模块分析

### 1. AudioControlLooper类
**功能**: 音频控制消息循环处理器，使用单例模式
**核心组件**:
- Looper: Android消息循环机制
- std::thread: C++11线程
- std::atomic<bool>: 原子布尔类型用于线程同步
- IAudioControl: HIDL接口客户端

#### 构造函数
```cpp
AudioControlLooper::AudioControlLooper() {
    mLooper = new Looper(false);
    mStopThread = false;
    mThread = std::thread(&AudioControlLooper::ThreadLoop, this);
}
```

#### ThreadLoop()
**功能**: 消息循环线程主函数
**实现逻辑**:
- 设置当前线程的Looper
- 循环调用mLooper->pollOnce(200)处理消息
- 200ms超时，避免线程阻塞

### 2. 消息处理

#### AudioControlMessageHandler::handleMessage()
**功能**: 处理音频控制消息
**支持的消息类型**:
1. 媒体路径消息：
   - MSG_SET_MEDIA_PATH_STEREO (0x00000001)
   - MSG_SET_MEDIA_PATH_SURROUND_7P1P2 (0x00000002)
   - MSG_SET_MEDIA_PATH_SURROUND_7P1 (0x00000003)
   - MSG_SET_MEDIA_PATH_SURROUND_7P1P4 (0x00000004)
   - MSG_SET_MEDIA_PATH_SURROUND_5P1 (0x00000005)

2. 媒体源消息：
   - MSG_SET_MEDIA_SOURCE_MEDIA (0x01000000)
   - MSG_SET_MEDIA_SOURCE_GAME (0x01000004)
   - MSG_SET_MEDIA_SOURCE_TUNER (0x0100000E)

**实现逻辑**:
- 使用fallthrough模式处理相似消息
- 调用HIDL接口与DSP通信
- 错误日志记录

### 3. 外部接口

#### audio_control_init()
**功能**: 初始化音频控制模块
**实现逻辑**:
1. 获取IAudioControl HIDL服务
2. 检查服务是否可用
3. 启动消息循环线程

#### audio_control_set_media_path()
**功能**: 设置媒体路径
**支持的路径**:
- MEDIA_PATH_STEREO (1): 立体声
- MEDIA_PATH_SURROUND_7P1P2 (2): 7.1.2环绕声  
- MEDIA_PATH_SURROUND_7P1 (3): 7.1环绕声
- MEDIA_PATH_SURROUND_7P1P4 (4): 7.1.4环绕声
- MEDIA_PATH_SURROUND_5P1 (5): 5.1环绕声

#### audio_control_set_media_source()
**功能**: 设置媒体源
**支持的源**:
- MEDIA_SOURCE_MEDIA (0): 普通媒体
- MEDIA_SOURCE_GAME (4): 游戏音频
- MEDIA_SOURCE_TUNER (14): 调谐器音频

## 编译配置分析

### Android.mk关键配置
```makefile
# 根据SYNCORE_PRODUCT环境变量选择模块名
ifeq ($(SYNCORE_PRODUCT),)
LOCAL_MODULE :=audio.primary.$(TARGET_BOARD_HARDWARE)
else
LOCAL_MODULE :=audio.primary.$(TARGET_BOARD_PLATFORM)
endif

# 源文件
LOCAL_SRC_FILES := audio_hw.c hfp.c audio_control.cpp

# 依赖库
LOCAL_SHARED_LIBRARIES := \
    liblog libcutils libaudioutils \
    libaudioroute libspeexresampler libasound \
    android.hardware.dsp@1.0 libutils libhidlbase
```

## 特性总结

### 1. 支持的音频特性
- **多声道支持**: 立体声到12声道（7.1.4）
- **多采样率**: 8kHz到48kHz
- **多格式**: PCM 16位和32位
- **重采样**: 支持实时重采样
- **增益控制**: -32dB到6dB，步长1dB
- **音量渐变**: 录音启动时渐变处理

### 2. 音频总线架构
- **媒体总线**: BUS00_MEDIA, BUS15_MEDIA_HIFI_712_OUT等
- **通话总线**: BUS04_CALL_OUT
- **语音总线**: BUS02_VOICE_COMMAND_OUT
- **系统总线**: BUS06_NOTIFICATION_OUT
- **蓝牙总线**: BUS99_BT_UPLINK_OUT, BUS07_BT_DOWNLINK_IN
- **语音识别**: BUS00_VR_IN（12通道）

### 3. HFP蓝牙通话特性
- **双向音频流**: 同时支持上行和下行
- **多采样率**: 8kHz和16kHz
- **实时处理**: 使用实时线程优先级
- **错误恢复**: 完善的ALSA错误处理机制
- **调试支持**: 音频数据转储功能

### 4. DSP音频控制
- **HIDL接口**: 通过Hardware Interface Definition Language与DSP通信
- **异步处理**: 消息队列异步处理控制命令
- **多媒体路径**: 支持立体声到7.1.4的多种音频路径
- **音频源切换**: 支持媒体、游戏、调谐器等音频源

### 5. 调试和监控
- **性能追踪**: 使用ATRACE进行性能分析
- **音频转储**: 支持输入输出音频数据转储
- **错误日志**: 详细的错误日志记录
- **状态监控**: 完善的设备和流状态管理

## 总结

3588项目的AudioHal实现是一个功能完整、架构清晰的音频硬件抽象层。它基于ALSA音频架构，支持多种音频格式和总线配置，特别针对车载音频场景进行了优化。主要特点包括：

1. **模块化设计**: 清晰分离音频流处理、HFP通话、DSP控制等功能模块
2. **多声道支持**: 从立体声到12声道的完整支持
3. **实时性能**: HFP使用实时线程确保通话质量
4. **错误处理**: 完善的ALSA错误恢复机制
5. **调试支持**: 丰富的调试和监控功能

该实现为3588平台提供了稳定可靠的音频硬件抽象层，能够满足车载音频系统的复杂需求。
